FILE: exclusions.kt
    @R|kotlin/annotation/Target|(allowedTargets = vararg(Q|kotlin/annotation/AnnotationTarget|.R|kotlin/annotation/AnnotationTarget.CLASS|, Q|kotlin/annotation/AnnotationTarget|.R|kotlin/annotation/AnnotationTarget.PROPERTY|, Q|kotlin/annotation/AnnotationTarget|.R|kotlin/annotation/AnnotationTarget.FUNCTION|)) @R|kotlin/Suppress|(names = vararg(String(ClassName))) public final annotation class _Discardable : R|kotlin/Annotation| {
        public constructor(): R|_Discardable| {
            super<R|kotlin/Any|>()
        }

    }
    public final fun stringF(): R|kotlin/String| {
        ^stringF String()
    }
    public final fun nsf(): R|kotlin/String?| {
        ^nsf String(null)
    }
    public final fun coll(m: R|kotlin/collections/MutableCollection<kotlin/String>|): R|kotlin/Unit| {
        R|<local>/m|.R|SubstitutionOverride<kotlin/collections/MutableCollection.add: R|kotlin/Boolean|>|(String())
    }
    public final fun exlusionPropagation(cond: R|kotlin/Boolean|, m: R|kotlin/collections/MutableList<kotlin/String>|): R|kotlin/Unit| {
        when () {
            R|<local>/cond| ->  {
                R|<local>/m|.R|SubstitutionOverride<kotlin/collections/MutableList.add: R|kotlin/Boolean|>|(String(x))
            }
            else ->  {
                throw R|java/lang/IllegalStateException.IllegalStateException|()
            }
        }

        when () {
            R|<local>/cond| ->  {
                R|/stringF|()
            }
            else ->  {
                throw R|java/lang/IllegalStateException.IllegalStateException|()
            }
        }

    }
    @R|_Discardable|() public final fun discardable(): R|kotlin/String| {
        ^discardable String()
    }
    public final fun unused(cond: R|kotlin/Boolean|): R|kotlin/Unit| {
        R|/stringF|()
        R|/discardable|()
        when () {
            R|<local>/cond| ->  {
                R|/discardable|()
            }
            else ->  {
                R|/stringF|()
            }
        }

        when () {
            R|<local>/cond| ->  {
                R|/discardable|()
            }
            else ->  {
                Q|kotlin/Unit|
            }
        }

    }
    public final fun underscore(): R|kotlin/Unit| {
        lval _: R|kotlin/String| = R|/stringF|()
    }
